package com.mak.service;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.docx4j.Docx4J;
import org.docx4j.XmlUtils;
import org.docx4j.fonts.BestMatchingMapper;
import org.docx4j.fonts.Mapper;
import org.docx4j.fonts.PhysicalFonts;
import org.docx4j.openpackaging.exceptions.Docx4JException;
import org.docx4j.openpackaging.packages.WordprocessingMLPackage;
import org.docx4j.openpackaging.parts.WordprocessingML.MainDocumentPart;
import org.docx4j.wml.Text;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * A comprehensive service for processing DOCX templates with metadata placeholders and converting them to PDF.
 * 
 * <p>This service provides functionality to:</p>
 * <ul>
 *   <li>Load DOCX templates from resources or file system</li>
 *   <li>Replace placeholders in the format [@KEY] with provided values</li>
 *   <li>Convert processed documents to PDF format</li>
 *   <li>Support both single and parallel batch processing</li>
 * </ul>
 * 
 * <p>Thread-safe and designed for high-performance batch operations.</p>
 * 
 * @author Generated by code review
 * @version 2.0
 * @since 1.8
 */
public class DocTemplateService {
    
    private static final Logger logger = LogManager.getLogger(DocTemplateService.class);
    
    // Configuration constants
    private static final String DEFAULT_OUTPUT_DIRECTORY = "pdfs";
    private static final String PDF_EXTENSION = ".pdf";
    private static final Pattern PLACEHOLDER_PATTERN = Pattern.compile("\\[@([^]]+)]");
    private static final String THREAD_NAME_PREFIX = "pdf-worker-";
    
    // Thread management
    private static final AtomicInteger threadCounter = new AtomicInteger(0);
    
    // Instance configuration
    private final Path outputDirectory;
    private final ResourceLoader resourceLoader;
    private final FontConfigurationStrategy fontStrategy;
    private final PlaceholderReplacementStrategy placeholderStrategy;
    
    /**
     * Creates a new DocTemplateService with default configuration.
     * Output directory will be "pdfs" in the current working directory.
     */
    public DocTemplateService() {
        this(Paths.get(DEFAULT_OUTPUT_DIRECTORY));
    }
    
    /**
     * Creates a new DocTemplateService with custom output directory.
     * 
     * @param outputDirectory the directory where PDF files will be generated
     * @throws IllegalArgumentException if outputDirectory is null
     */
    public DocTemplateService(Path outputDirectory) {
        if (outputDirectory == null) {
            throw new IllegalArgumentException("Output directory cannot be null");
        }
        
        this.outputDirectory = outputDirectory;
        this.resourceLoader = new ClasspathResourceLoader();
        this.fontStrategy = new DefaultFontConfigurationStrategy();
        this.placeholderStrategy = new ParagraphAwarePlaceholderStrategy();
        
        logger.debug("DocTemplateService initialized with output directory: {}", 
                    outputDirectory.toAbsolutePath());
    }
    
    /**
     * Generates a PDF by loading a DOCX template, replacing placeholders, and converting to PDF.
     * 
     * <p>Placeholders should be in the format [@KEY] where KEY corresponds to keys in the metadata map.</p>
     * 
     * @param templateFileName the template file name (searched in classpath resources)
     * @param metadata map of placeholder keys to replacement values (null values become empty strings)
     * @param outputFileName desired output PDF file name (with or without .pdf extension)
     * @return the Path to the generated PDF file
     * @throws IllegalArgumentException if templateFileName or outputFileName is null/empty
     * @throws IOException if file operations fail
     * @throws Docx4JException if document processing fails
     * @throws TemplateProcessingException if template loading or processing fails
     */
    public Path generatePdf(String templateFileName, Map<String, String> metadata, String outputFileName) 
            throws IOException, Docx4JException, TemplateProcessingException {
        
        validateInputs(templateFileName, outputFileName);
        
        String normalizedOutputName = normalizeFileName(outputFileName);
        Map<String, String> safeMetadata = metadata != null ? metadata : Collections.emptyMap();
        
        logger.info("Starting PDF generation: template='{}', output='{}', placeholders={}", 
                   templateFileName, normalizedOutputName, safeMetadata.size());
        
        try (InputStream templateStream = resourceLoader.loadResource(templateFileName)) {
            WordprocessingMLPackage document = loadDocument(templateStream, templateFileName);
            configureDocument(document);
            processPlaceholders(document, safeMetadata);
            return convertToPdf(document, normalizedOutputName);
            
        } catch (Exception e) {
            logger.error("Failed to generate PDF: template='{}', output='{}'", 
                        templateFileName, normalizedOutputName, e);
            if (e instanceof IOException) throw (IOException) e;
            if (e instanceof Docx4JException) throw (Docx4JException) e;
            if (e instanceof TemplateProcessingException) throw (TemplateProcessingException) e;
            throw new TemplateProcessingException("Unexpected error during PDF generation", e);
        }
    }
    
    /**
     * Generates multiple PDFs in parallel using separate metadata for each template.
     * 
     * <p>This method processes multiple templates concurrently to improve performance.
     * The number of threads used is automatically determined based on available processors
     * and the number of tasks.</p>
     * 
     * @param requests list of PDF generation requests
     * @return list of Paths to generated PDF files, in the same order as requests
     * @throws IllegalArgumentException if requests is null or empty
     * @throws IOException if any file operation fails
     * @throws Docx4JException if any document processing fails
     * @throws TemplateProcessingException if any template processing fails
     */
    public List<Path> generatePdfsParallel(List<PdfGenerationRequest> requests) 
            throws IOException, Docx4JException, TemplateProcessingException {
        
        if (requests == null || requests.isEmpty()) {
            throw new IllegalArgumentException("Requests list cannot be null or empty");
        }
        
        int threadCount = calculateOptimalThreadCount(requests.size());
        logger.info("Starting parallel PDF generation: {} requests, {} threads", 
                   requests.size(), threadCount);
        
        ExecutorService executor = createExecutorService(threadCount);
        
        try {
            List<Future<Path>> futures = submitTasks(executor, requests);
            return collectResults(futures);
            
        } finally {
            shutdownExecutor(executor);
        }
    }
    
   // Private methods for core functionality
    
    private void validateInputs(String templateFileName, String outputFileName) {
        if (templateFileName == null || templateFileName.trim().isEmpty()) {
            throw new IllegalArgumentException("Template file name cannot be null or empty");
        }
        if (outputFileName == null || outputFileName.trim().isEmpty()) {
            throw new IllegalArgumentException("Output file name cannot be null or empty");
        }
    }
    
    private String normalizeFileName(String fileName) {
        return fileName.endsWith(PDF_EXTENSION) ? fileName : fileName + PDF_EXTENSION;
    }
    
    private WordprocessingMLPackage loadDocument(InputStream templateStream, String templateFileName) 
            throws TemplateProcessingException {
        try {
            WordprocessingMLPackage document = WordprocessingMLPackage.load(templateStream);
            logger.debug("Successfully loaded document: {}", templateFileName);
            return document;
        } catch (Docx4JException e) {
            throw new TemplateProcessingException("Failed to load template: " + templateFileName, e);
        }
    }
    
    private void configureDocument(WordprocessingMLPackage document) {
        try {
            fontStrategy.configureFonts(document);
            logger.debug("Document font configuration completed");
        } catch (Exception e) {
            logger.warn("Font configuration failed, proceeding with defaults", e);
        }
    }
    
    private void processPlaceholders(WordprocessingMLPackage document, Map<String, String> metadata) 
            throws Docx4JException {
        try {
            placeholderStrategy.replacePlaceholders(document.getMainDocumentPart(), metadata);
            logger.debug("Placeholder replacement completed: {} placeholders", metadata.size());
        } catch (Exception e) {
            throw new Docx4JException("Failed to replace placeholders", e);
        }
    }
    
    private Path convertToPdf(WordprocessingMLPackage document, String outputFileName) 
            throws IOException, Docx4JException {
        
        ensureOutputDirectoryExists();
        Path outputPath = outputDirectory.resolve(outputFileName);
        
        logger.info("Converting to PDF: {}", outputPath.toAbsolutePath());
        
        try (OutputStream outputStream = Files.newOutputStream(outputPath)) {
            Docx4J.toPDF(document, outputStream);
        } catch (NoClassDefFoundError e) {
            throw new Docx4JException(
                "Missing PDF export dependencies. Ensure 'org.docx4j:docx4j-export-fo' is on the classpath.", e);
        }
        
        logger.info("PDF generated successfully: {}", outputPath.toAbsolutePath());
        return outputPath;
    }
    
    private void ensureOutputDirectoryExists() throws IOException {
        if (!Files.exists(outputDirectory)) {
            Files.createDirectories(outputDirectory);
            logger.debug("Created output directory: {}", outputDirectory.toAbsolutePath());
        }
    }
    
    // Parallel processing methods
    
    private int calculateOptimalThreadCount(int taskCount) {
        int availableProcessors = Runtime.getRuntime().availableProcessors();
        return Math.min(taskCount, Math.max(1, availableProcessors));
    }
    
    private ExecutorService createExecutorService(int threadCount) {
        ThreadFactory threadFactory = task -> {
            Thread thread = new Thread(task);
            thread.setName(THREAD_NAME_PREFIX + threadCounter.incrementAndGet());
            thread.setDaemon(true);
            return thread;
        };
        
        return Executors.newFixedThreadPool(threadCount, threadFactory);
    }
    
    private List<Future<Path>> submitTasks(ExecutorService executor, List<PdfGenerationRequest> requests) {
        List<Future<Path>> futures = new ArrayList<>(requests.size());
        
        for (int i = 0; i < requests.size(); i++) {
            final int taskIndex = i;
            final PdfGenerationRequest request = requests.get(i);
            
            Callable<Path> task = () -> {
                String threadName = Thread.currentThread().getName();
                logger.info("[{}] Task #{} started: {} -> {}", 
                          threadName, taskIndex + 1, request.getTemplateFileName(), request.getOutputFileName());
                
                try {
                    Path result = generatePdf(request.getTemplateFileName(), 
                                            request.getMetadata(), 
                                            request.getOutputFileName());
                    logger.info("[{}] Task #{} completed: {}", 
                              threadName, taskIndex + 1, result.toAbsolutePath());
                    return result;
                } catch (Exception e) {
                    logger.error("[{}] Task #{} failed: {} -> {}", 
                               threadName, taskIndex + 1, request.getTemplateFileName(), 
                               request.getOutputFileName(), e);
                    throw new RuntimeException("Task #" + (taskIndex + 1) + " failed", e);
                }
            };
            
            futures.add(executor.submit(task));
        }
        
        return futures;
    }
    
    private List<Path> collectResults(List<Future<Path>> futures) 
            throws IOException, Docx4JException, TemplateProcessingException {
        
        List<Path> results = new ArrayList<>(futures.size());
        List<Exception> failures = new ArrayList<>();
        
        for (int i = 0; i < futures.size(); i++) {
            try {
                Path result = futures.get(i).get();
                results.add(result);
            } catch (ExecutionException e) {
                Throwable cause = e.getCause();
                if (cause instanceof Exception) {
                    failures.add((Exception) cause);
                } else {
                    failures.add(new RuntimeException("Task #" + (i + 1) + " failed", cause));
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new TemplateProcessingException("Parallel processing interrupted", e);
            }
        }
        
        if (!failures.isEmpty()) {
            handleParallelProcessingFailures(failures);
        }
        
        logger.info("Parallel PDF generation completed successfully: {} files", results.size());
        return results;
    }
    
    private void handleParallelProcessingFailures(List<Exception> failures) 
            throws IOException, Docx4JException, TemplateProcessingException {
        
        // Check for specific exception types to rethrow appropriately
        for (Exception failure : failures) {
            if (failure instanceof TemplateProcessingException) {
                throw (TemplateProcessingException) failure;
            }
            if (failure instanceof Docx4JException) {
                throw (Docx4JException) failure;
            }
            if (failure instanceof IOException) {
                throw (IOException) failure;
            }
        }
        
        // If we get here, create a compound exception
        TemplateProcessingException compound = new TemplateProcessingException(
            failures.size() + " task(s) failed during parallel processing");
        failures.forEach(compound::addSuppressed);
        throw compound;
    }
    
    private void shutdownExecutor(ExecutorService executor) {
        executor.shutdownNow();
        try {
            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                logger.warn("Executor did not terminate within 5 seconds");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.warn("Interrupted while waiting for executor termination");
        }
        logger.debug("Executor service shut down completed");
    }
    
    // Strategy interfaces and implementations
    
    /**
     * Strategy interface for loading template resources.
     */
    private interface ResourceLoader {
        InputStream loadResource(String resourceName) throws IOException, TemplateProcessingException;
    }
    
    /**
     * Default implementation that loads resources from classpath.
     */
    private static class ClasspathResourceLoader implements ResourceLoader {
        @Override
        public InputStream loadResource(String resourceName) throws IOException, TemplateProcessingException {
            String normalizedName = resourceName.startsWith("/") ? resourceName : ("/" + resourceName);
            
            URL url = getClass().getResource(normalizedName);
            if (url == null) {
                // Fallback: try without leading slash
                url = getClass().getResource(resourceName);
            }
            
            if (url == null) {
                throw new TemplateProcessingException("Template not found in classpath: " + resourceName);
            }
            
            return url.openStream();
        }
    }
    
    /**
     * Strategy interface for font configuration.
     */
    private interface FontConfigurationStrategy {
        void configureFonts(WordprocessingMLPackage document) throws Exception;
    }
    
    /**
     * Default font configuration strategy using system fonts.
     */
    private static class DefaultFontConfigurationStrategy implements FontConfigurationStrategy {
        @Override
        public void configureFonts(WordprocessingMLPackage document) throws Exception {
            PhysicalFonts.discoverPhysicalFonts();
            Mapper fontMapper = new BestMatchingMapper();
            document.setFontMapper(fontMapper);
        }
    }
    
    /**
     * Strategy interface for placeholder replacement.
     */
    private interface PlaceholderReplacementStrategy {
        void replacePlaceholders(MainDocumentPart mainPart, Map<String, String> metadata) throws Exception;
    }
    
    /**
     * Advanced placeholder replacement strategy that handles placeholders split across text runs.
     */
    private static class ParagraphAwarePlaceholderStrategy implements PlaceholderReplacementStrategy {
        

        @Override
        public void replacePlaceholders(MainDocumentPart mainPart, Map<String, String> metadata) throws Exception {
            List<Object> textNodes = mainPart.getJAXBNodesViaXPath("//w:t", true);
            Map<Object, List<Text>> paragraphToTexts = groupTextNodesByParagraph(textNodes);
            
            for (Map.Entry<Object, List<Text>> entry : paragraphToTexts.entrySet()) {
                processTextGroup(entry.getValue(), metadata);
            }
        }
        
        private Map<Object, List<Text>> groupTextNodesByParagraph(List<Object> textNodes) {
            // Use LinkedHashMap to preserve document order
            Map<Object, List<Text>> paragraphToTexts = new LinkedHashMap<>();
            
            for (Object node : textNodes) {
                Object unwrapped = XmlUtils.unwrap(node);
                if (unwrapped instanceof Text) {
                    Text textNode = (Text) unwrapped;
                    Object paragraph = findParagraphAncestor(textNode);
                    
                    if (paragraph != null) {
                        paragraphToTexts.computeIfAbsent(paragraph, k -> new ArrayList<>()).add(textNode);
                    } else {
                        // Process isolated text nodes directly - will be handled separately
                        paragraphToTexts.computeIfAbsent(textNode, k -> new ArrayList<>()).add(textNode);
                    }
                }
            }
            
            return paragraphToTexts;
        }
        
        private Object findParagraphAncestor(Text textNode) {
            Object current = textNode;
            
            // Walk up the parent chain to find paragraph (w:p)
            while (current != null) {
                if (current instanceof org.docx4j.wml.P) {
                    return current;
                }
                current = getParentSafely(current);
            }
            
            return null;
        }
        
        private Object getParentSafely(Object node) {
            // Try getParent() method first
            try {
                return node.getClass().getMethod("getParent").invoke(node);
            } catch (Exception e) {
                // Silently fall back to reflection on parent field
            }
            
            // Try parent field access
            try {
                java.lang.reflect.Field parentField = node.getClass().getDeclaredField("parent");
                parentField.setAccessible(true);
                return parentField.get(node);
            } catch (Exception e) {
                // Give up
                return null;
            }
        }
        
        private void processTextGroup(List<Text> textNodes, Map<String, String> metadata) {
            if (textNodes.isEmpty()) return;
            
            // Combine all text values
            StringBuilder combinedText = new StringBuilder();
            for (Text textNode : textNodes) {
                String value = textNode.getValue();
                if (value != null) {
                    combinedText.append(value);
                }
            }
            
            String originalText = combinedText.toString();
            if (originalText.isEmpty()) return;
            
            String replacedText = replacePlaceholders(originalText, metadata);
            
            if (!replacedText.equals(originalText)) {
                // Put all replaced text in the first node, clear others
                boolean isFirst = true;
                for (Text textNode : textNodes) {
                    if (isFirst) {
                        textNode.setValue(replacedText);
                        isFirst = false;
                    } else {
                        textNode.setValue("");
                    }
                }
            }
        }
        
        private String replacePlaceholders(String text, Map<String, String> metadata) {
            if (text == null || text.isEmpty()) return text;
            
            Matcher matcher = PLACEHOLDER_PATTERN.matcher(text);
            StringBuffer result = new StringBuffer();
            
            while (matcher.find()) {
                String key = matcher.group(1);
                String replacement = metadata.getOrDefault(key, "");
                // Escape dollar signs and backslashes for proper replacement
                replacement = replacement.replace("\\", "\\\\").replace("$", "\\$");
                matcher.appendReplacement(result, replacement);
            }
            matcher.appendTail(result);
            
            return result.toString();
        }
    }
    
    /**
     * Value object representing a PDF generation request.
     */
    public static class PdfGenerationRequest {
        private final String templateFileName;
        private final Map<String, String> metadata;
        private final String outputFileName;
        
        /**
         * Creates a new PDF generation request.
         * 
         * @param templateFileName the template file name
         * @param metadata the placeholder metadata
         * @param outputFileName the output file name
         */
        public PdfGenerationRequest(String templateFileName, Map<String, String> metadata, String outputFileName) {
            this.templateFileName = Objects.requireNonNull(templateFileName, "Template file name cannot be null");
            this.metadata = metadata != null ? Collections.unmodifiableMap(new HashMap<>(metadata)) : Collections.emptyMap();
            this.outputFileName = Objects.requireNonNull(outputFileName, "Output file name cannot be null");
        }
        
        public String getTemplateFileName() { return templateFileName; }
        public Map<String, String> getMetadata() { return metadata; }
        public String getOutputFileName() { return outputFileName; }
        
        @Override
        public String toString() {
            return String.format("PdfGenerationRequest{template='%s', output='%s', metadata=%d keys}", 
                               templateFileName, outputFileName, metadata.size());
        }
    }
    
    /**
     * Custom exception for template processing errors.
     */
    public static class TemplateProcessingException extends Exception {
        public TemplateProcessingException(String message) {
            super(message);
        }
        
        public TemplateProcessingException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}